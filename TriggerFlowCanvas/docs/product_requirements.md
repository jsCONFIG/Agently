# TriggerFlow Canvas 产品需求文档

## 一、背景与目标
TriggerFlow Canvas 旨在为使用 Agently TriggerFlow 工作流引擎的开发者和产品团队提供一个所见即所得的流程编排工具。现有 TriggerFlow 具备强大的可编程能力，但缺少低门槛的可视化搭建体验。本项目的目标是：

- 提供一个基于浏览器的拖拽式画布，让用户可以快速搭建线性的 TriggerFlow 工作流。
- 提供将可视化结果与 TriggerFlow 引擎互通的能力，实现“所见即所得 + 即刻运行”。
- 打包成可本地启动、可 Docker 化部署的一体化解决方案，方便在团队内部演示或试用。

## 二、用户角色与场景
- **产品经理 / 业务运营人员**：无需了解 Python 代码即可设计基本的对话或文本处理流程。
- **开发者**：验证流程逻辑、快速调试 TriggerFlow 功能，并可导出为 JSON 配置交给后端集成。
- **演示人员**：在分享 TriggerFlow 能力时以可视化方式呈现，降低讲解成本。

典型使用场景包括：
1. 团队讨论新业务流程，使用 Canvas 快速绘制原型并保存。
2. 在本地运行流程，验证 Echo/LLM 等节点执行效果和数据传递。
3. 通过 Docker 镜像部署在线演示环境供伙伴试用。

## 三、范围与功能需求
### 3.1 必须实现
1. **画布操作**
   - 加载默认流程，并支持在画布上拖拽节点位置。
   - 支持新增 Echo、Uppercase、LLM、Output 节点；仅允许单线性连接，保证与 TriggerFlow 的映射简单一致。
   - 支持连接模式下依次选择两个节点建立单向连接；每个节点只允许一个后继节点，确保线性。
   - 支持删除非起始节点。
2. **节点配置**
   - 可编辑节点名称与特定配置项（例如 Echo 模板、LLM 提示词、Output 标签）。
3. **工作流持久化**
   - 将当前画布状态保存为 JSON，并支持刷新后重新加载。
4. **与 TriggerFlow 引擎联动**
   - 前端触发执行请求，后端根据 JSON 构建 TriggerFlow 并运行，返回最终结果与耗时。
5. **部署要求**
   - 提供基于 Python 标准库的 HTTP 后端，托管静态前端资源并暴露 REST 接口。
   - 提供 Dockerfile，支持一键打包运行。

### 3.2 可选增强（非本轮实现）
- 分支/并行节点支持。
- WebSocket 实时执行流式反馈。
- 节点库扩展至自定义 Python 函数或三方工具。
- 多人协作与版本管理。

## 四、非功能需求
- 前端 UI 需要自适应常见桌面浏览器，基于 React + ReactFlow 实现顺畅的拖拽体验。
- 后端代码遵循 Pydantic 校验规范，保持较高可测试性。
- 提供完善文档，涵盖架构说明、接口说明、部署与测试指南。

## 五、验收标准
- 启动后端服务后访问首页可看到画布并操作节点，保存/运行按钮可正常工作。
- `POST /api/execute` 在提供合法流程时返回执行结果；对于不合法流程返回 400。
- `pytest` 通过新增的 TriggerFlow Canvas 相关测试。
- Docker 镜像构建成功，容器运行后可访问可视化界面并执行默认流程。

